Plan for today:

Up next: 
	* List comprehensions - check accuracy !
  * Example of deconstruction
  		* Interning as cacheing of overlapping structures ???
	* Add test to show Java 8 mutability checks for lambdas
  * Lazy evaluation comments
  * Double check all examples
  * Show using unapply to define additional cases for pattern matching
  * Does pattern matching require immutability?    
  
  * Do I need to add anything to the Von Neumann Languages page?
  * Can I have more examples of converting code to pure func? - maybe a slide?
  * Where to add the item about FP's core value being simplicity
  * Expressions vs Statements - check for more  
  * Do we still want the 'FP Big Idea' sections?
  * Add Java 8 examples in the slides
	
Notes:

- Mathematical properties: describe mapping things to categories / property of discovering behavior when mapped to other categories
- Why is parallelization hard?
  - Mutability, shared state
  - Not pure functions
- Referential transparency: analyzable in isolation
- (Somewhere): Example about proofs - what if we change a 'given'?
- Declarative programming: a trend as computers get faster
- Immutability: Spring, constructor injection, spring + scala
- Purity: 100% not realistic
- Higher order functions: FP big idea - simplifying things by getting rid of extraneous concepts/divisions: statements vs. expressions, functions vs. values.  Remember - everything is an object?
- Language examples:
	- Compromises (Streams, ranges, functional interfaces, defining functions as curryable, partial application requires special syntax, etc.)
- Code example: 
  - Show basic overview
  - Show order processor
  	- Immutability, higher order functions
  - Show test isolation problem
  - Show test speed problem
  - Show production code speed problem
- Practical advice
  - Focus on ref. transp., immutability, pure functions
  - Try it with test code
  - Turn on random run order
  - Turn on parallel execution
- Functional thinking
  - Test data grouped by context
  - Test data as defs  
- (Somewhere) FP Big idea: making errors inexpressible

      
      
Guidelines:

- Beware the narrow focus.  For each point, think more broadly to see if I'm omitting or missing something.
- Do NOT get 'ahead of my knowledge'.
- Practice the presentation to see how the time limit feels.
- Throw in a joke or two.
- When in doubt, lean on clarifying and exemplifying concepts rather than expounding on benefits
- Make small claims.
- Realize that the goal is just to impart a little knowledge.  90 minutes isn't going to change the world.
- Think about how I would explain it to a team member.
- Write the slide first, then read more - helps build confidence because I will find that I know more than I think.


Quotes:

"Eliminating side effects, i.e. changes in state that do not depend on the function inputs, can make it much easier to understand and predict the behavior of a program, which is one of the key motivations for the development of functional programming." - Wikipedia fp
"An expression is said to be referentially transparent if it can be replaced with its value without changing the behavior of a program (in other words, yielding a program that has the same effects and output on the same input)." - wikipedia fp
"For example, when programming in C, there will be a performance penalty for including a call to an expensive function inside a loop, even if the function call could be moved outside of the loop without changing the results of the program. The programmer would be forced to perform manual code motion of the call, possibly at the expense of source code readability. However, if the compiler is able to determine that the function call is referentially transparent, it can perform this transformation automatically." - wikipedia referential transparency
"Purely functional functions (or expressions) have no side effects (memory or I/O). This means that pure functions have several useful properties, many of which can be used to optimize the code:
"If the result of a pure expression is not used, it can be removed without affecting other expressions.
"If a pure function is called with arguments that cause no side-effects, the result is constant with respect to that argument list (sometimes called referential transparency), i.e. if the pure function is again called with the same arguments, the same result will be returned (this can enable caching optimizations such as memoization).
"If there is no data dependency between two pure expressions, then their order can be reversed, or they can be performed in parallel and they cannot interfere with one another (in other terms, the evaluation of any pure expression is thread-safe).
"If the entire language does not allow side-effects, then any evaluation strategy can be used; this gives the compiler freedom to reorder or combine the evaluation of expressions in a program (for example, using deforestation)." - wikipedia FP
"Functional programming is very much about using mathematics to reason about programs. To do so, one needs a formalism that describe the programs and how one can make proofs about properties they might have." - Daniel C. Sobral

Examples:

Tests which fail when run in Idea but pass in Maven due to test class ordering
Tests which cannot be run by themselves due to poor test isolation
Tests which have to be careful about cleaning up after themselves because of shared resources
Tests which are flaky due to sensitivity to outside influences such as the date
Use of closures to guarantee 'before and after' behavior
Idempotency desired, e.g. calculate new bank balance.  Separate calculation from storage/retrieval.
Writing code without '='
Memoizing in groovy
How it all can fall down if something is mutable


Tasks:

- Read "Functional Thinking"
- Read chapter on Monads in Haskell book