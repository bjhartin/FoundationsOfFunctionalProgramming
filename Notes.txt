Show a program composed purely of expressions, vs. one of statements and expressions.


Slide: Purity
Slide: Currying vs. Partial Application
Slide: Viewing these techniques as code reuse

- Viewing state as complexity
- Being able to choose when you want to do something could be just choosing a type.
________________________________________
From: Brian Hartin
Sent: Wednesday, April 23, 2014 9:17 PM
To: brian.hartin@gmail.com
Cc: Brian Hartin
Subject: FP presentation

Key ideas I want to communicate:

- Really good explanation of some of the core ideas of functional programming
- Most common languages reflect the architecture of the computer.
-- A lot of complexity in computer programming is due to this.  Realizing it can help you simplify things.
- The killer feature of functional programming is to break away from this, and reason in a more formal way.
- The idea of a function in mathematics and a 'pure function' in programming.
- How writing parts of your code as pure functions can make that code:
  - Easier to understand (especially in isolation)
  - Less sensitive to flaky errors
  - Easier to parallelize
  - Easier to cache
  - Easier to compose
- Foundations for understanding any functional programming language
- Sense of the mathematical foundations

Slides:

Tonight's Presentation
----------------------

* Who am I?
  * Background, etc.
  * Began using languages with functional aspects in 2006: Ruby -> Groovy -> Scala -> Haskell
  ** The functional parts of these languages changed my thinking dramatically
  ** I realized that a lot of material on functional programming focuses on the language features, and less on some of the foundations
  ** Learning the cross-language foundations made it very easy to learn other languages
  ** Eliminated a lot of complexity
* Why am I doing this?
* What I hope to leave you with:
  * An understanding of core FP concepts
  * An awareness of certain kinds of complexity
  * Some new tools to solve tricky problems
* What this talk is NOT
  * A complete explanation of functional programming
  * A 'FP will save the world!' talk

Foundations of Functional Programming
------------------------------------

** Backus' paper
** Key claims
** Resulting research

Von Neumann Languages
---------------------

** Most of our common imperative languages fit into this group (even if they have some functional features)
** Leaky abstractions for the computer

                program variables <-> computer storage cells
                control statements <-> computer test-and-jump instructions
                assignment statements <-> fetching, storing instructions
                expressions <-> memory reference and arithmetic instructions

** Key characteristic is hand-sequencing of instructions
*** Inevitable because of the tight relationship to the machine
*** Necessary to accomodate side effects
*** This sequencing, consideration of side-effects and thinking about overall program state is often a distraction from the real computations at hand.
** Shared state & mutability introduce complexity
*** OO as a way to manage state?
*** Examples: Java system properties.  Databases.  Ports.  Jmx resources.
** Did you know that the reason you thought about programming in this way was because of the hardware architecture?

Real-World Examples of Complexity Introduced by Von Neumann Reasoning
---------------------------------------------------------------------

* A calculation of a value A which depends on B, C, D and E.
** Computed as B -> C -> D -> E -> A
** Can I switch B & C?
* A series of Spring contexts which have dependencies, and which I must hand-sequence. ?
* The need to reset Java System Properties at the end of a test.

Functional Programming Motivations
----------------------------------

** Programs that have useful mathematical properties
*** Can write proofs
*** Can map to mathematical concepts such as group theory, category theory, etc. and 'reuse' the logic therein
*** Can compose programs (theoretically)
* [The killer feature of functional programming: thinking less about computers and more about computation]

NOTE: Consider a bit of 'why' for each one of these.

Functional Programming Concept: Expressions
-------------------------------------------

(Not all are present in all FP languages)

* Expressions
** Statements vs. Expressions
** No statements in pure FP languages
* Any statement may be a return value

Pure Functions
--------------

** Functions in the mathematical sense
*** Can create pure functions in any language
*** Must depend on nothing but the arguments (but not necessarily all of them)
*** Pure functions have many desirable qualities
**** Can have no effect other than to return a value (side-effect free)
**** Deterministic ('deterministic function' is redundant) (vertical line test) (vs. relation)
**** Idempotent
**** Referentially transparent
**** Opens the door for many compiler optimizations
** Examples of impure functions
** May help to think of them as mappings between domains
*** Pure is an abstraction
**** Side effects on memory, cpu usage, etc.

Immutable types
---------------

(From Learn You a Haskell for Great Good)

Me: "x = 3"
Computer: "Fine"
Me: "x = 4"
Computer: "Liar.  You said it was 3."

* What it says on the tin
* Necessary for pure functions
** Otherwise, might have side effects
* Enables certain kinds of cacheing (interning)
* Necessary for ADTs
* Possible performance penalty - see wikipedia article
* Possible performance gain

Higher order functions
----------------------



Application + Composibility
---------------------------

* Composibility as poor man's axiomatic reasoning
* Theoretically, pure functional languages allow programs to be proofs

Algebraic data types
--------------------

* Creating new type (alias) in Scala using apply/unapply and pattern for existing type with specific members
* Leveraging the ease of creating such types to make certain errors inexpressible
* Pattern matching
* Interning as cacheing of overlapping structures ???

List comprehensions
-------------------

* Mathematical origin: set builder notation
* Work on a type which boxes another type, e.g. List<T>, Map<K,V>
** Filter
** Map
** Fold (Reduce)
** Others: FlatMap, Flatten
** Other types: Either<T>, Option<T>
*** Functors
* Example of processing lines, validating, comprehending failures vs. successes using partition or similar and type aliases / extractors / whatever.

Partial Application / Currying
------------------------------

* Shout out to Haskell Curry
* Best definition is in Haskell

Declarative Programming
-----------------------

* Frees us, somewhat, from hand-sequencing
** SQL, XSLT as examples
** Somewhat harder to reason about performance
* Heavy use of recursion
** Recursion + accumulator instead of loop
** Tail recursion

Lazy Evaluation
---------------

Me: "Suppose we have a set.  Let's say the set of all integers."
Java: "WHAT?  Where will I put them all?"
Me: "Don't worry about that.  I just want to talk about them for now."
Java: "I have to put them somewhere."
Me: "Not yet."
Java: "You might need them."
Me: "No, I just want to think about about their properties - for example, what might happen if we mapped my shiny new function over them."
Java: "Sorry, but no.  If God wanted me to think about infinite lists, he would have given us infinite RAM."
Me: "Hey, Haskell..."




* Functional programming options on the JVM, including Java 8
 - Java 8
 - Groovy
 - Scala
 - Clojure

Functional Programming in Non-Functional Languages
--------------------------------------------------

Problems for Which FP is Well Suited
------------------------------------

IQAWIaNQtSiP: Interesting Questions About Which I am Not Qualified to Speak in Public
-------------------------------------------------------------------------------------

** lambda calculus
** Non-Von Neumann computer architectures
**



- Your table is a function
- Backus lecture
- FP's relationship to OO
- State: an alias for time
- What is FP good for?
- Why FP now?
- Pure vs. non-pure
- Theoretical basis
- Lambda calculus
- Memoization
- Delivery pipeline

- immutability
- side effect free
- ref transparency / determinism
- idempotency
- declarative
- closures / lambdas
- list comprehensions
 - filters
 - transforms
 - folds
- box of integers
- spring context example
- strict (eager) vs non-strict (lazy)

* Ways functional thinking reduces complexity

- Not thinking about program state
- Not sequencing
- Before and after

* functional thinking as aids test isolation

* Using it in parts of your program, e.g. a core rules module

* Resource contention

** The port problem I had when testing
** Test data grouped by context
** defs instead of shared objects in tests

* The difficult parts

** Managing I/O
** Reasoning about performance

* Effects on unit tests


Guidelines:

- Beware the narrow focus.  For each point, think more broadly to see if I'm omitting or missing something.
- Do NOT get 'ahead of my knowledge'.  Assume that, for each point, a follow up question or two will be asked.
- Practice the presentation to see how the time limit feels.
- Try to switch to code every few slides.
- Throw in a joke or two.
- When in doubt, lean on clarifying and exemplifying concepts rather than expounding on benefits
- Make small claims.
- Realize that the goal is just to impart a little knowledge.  90 minutes isn't going to change the world.
- Have sources for all statements that are surprising or controversial, unless they are completely original.  If the latter, have the explanation prepared.
- Think about how I would explain it to a team member.
- Write the slide first, then read more - helps build confidence because I will find that I know more than I think.

Quotes:

"Eliminating side effects, i.e. changes in state that do not depend on the function inputs, can make it much easier to understand and predict the behavior of a program, which is one of the key motivations for the development of functional programming." - Wikipedia fp
"An expression is said to be referentially transparent if it can be replaced with its value without changing the behavior of a program (in other words, yielding a program that has the same effects and output on the same input)." - wikipedia fp
"For example, when programming in C, there will be a performance penalty for including a call to an expensive function inside a loop, even if the function call could be moved outside of the loop without changing the results of the program. The programmer would be forced to perform manual code motion of the call, possibly at the expense of source code readability. However, if the compiler is able to determine that the function call is referentially transparent, it can perform this transformation automatically." - wikipedia referential transparency
"Purely functional functions (or expressions) have no side effects (memory or I/O). This means that pure functions have several useful properties, many of which can be used to optimize the code:
"If the result of a pure expression is not used, it can be removed without affecting other expressions.
"If a pure function is called with arguments that cause no side-effects, the result is constant with respect to that argument list (sometimes called referential transparency), i.e. if the pure function is again called with the same arguments, the same result will be returned (this can enable caching optimizations such as memoization).
"If there is no data dependency between two pure expressions, then their order can be reversed, or they can be performed in parallel and they cannot interfere with one another (in other terms, the evaluation of any pure expression is thread-safe).
"If the entire language does not allow side-effects, then any evaluation strategy can be used; this gives the compiler freedom to reorder or combine the evaluation of expressions in a program (for example, using deforestation)." - wikipedia FP
"Functional programming is very much about using mathematics to reason about programs. To do so, one needs a formalism that describe the programs and how one can make proofs about properties they might have." - Daniel C. Sobral

Examples:

Tests which fail when run in Idea but pass in Maven due to test class ordering
Tests which cannot be run by themselves due to poor test isolation
Tests which have to be careful about cleaning up after themselves because of shared resources
Tests which are flaky due to sensitivity to outside influences such as the date
Use of closures to guarantee 'before and after' behavior
Idempotency desired, e.g. calculate new bank balance.  Separate calculation from storage/retrieval.
Writing code without '='
Memoizing in groovy
How it all can fall down if something is mutable



Tasks:

- Read "Functional Thinking"
- Read chapter on Monads in Haskell book
- Write opening slides.
- Write examples for each functional programming concept.
- Come up with examples showing benefits (maybe same as above).
- Make immutable play nice with Spring